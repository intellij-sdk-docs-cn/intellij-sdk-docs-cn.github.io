


<!doctype html>
<html lang="en-US">
<head>
    <meta charset="UTF-8">
    <title>XML DOM API / IntelliJ Platform SDK  DevGuide</title>
    <link rel="stylesheet" href="/intellij/sdk/docs/app/app.css">
    <link rel="shortcut icon" href="/intellij/sdk/docs/favicon.ico" type="image/x-icon">
    <link rel="apple-touch-icon" sizes="57x57" href="/intellij/sdk/docs/apple-touch-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="/intellij/sdk/docs/apple-touch-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/intellij/sdk/docs/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/intellij/sdk/docs/apple-touch-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/intellij/sdk/docs/apple-touch-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/intellij/sdk/docs/apple-touch-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/intellij/sdk/docs/apple-touch-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/intellij/sdk/docs/apple-touch-icon-180x180.png">
    <link rel="mask-icon" href="/intellij/sdk/docs/apple-mask-icon.svg" color="black">
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="msapplication-square70x70logo" content="/intellij/sdk/docs/mstile-70x70.png">
    <meta name="msapplication-TileImage" content="/intellij/sdk/docs/mstile-144x144.png">
    <meta name="msapplication-square150x150logo" content="/intellij/sdk/docs/mstile-150x150.png">
    <meta name="msapplication-wide310x150logo" content="/intellij/sdk/docs/mstile-310x150.png">
    <meta name="msapplication-square310x310logo" content="/intellij/sdk/docs/mstile-310x310.png">
    <meta name="theme-color" content="#000000">
    <meta name="description" content="Documentation for working with and extending the IntelliJ Platform SDK" />
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://intellij-sdk-docs-cn.github.io/intellij/sdk/docs//reference_guide/frameworks_and_external_apis/xml_dom_api.html" />
    <meta property="og:site_name" content="JetBrains IntelliJ Platform SDK" />
    <meta property="og:title" content="XML DOM API" />
    <meta property="og:description" content="Documentation for working with and extending the IntelliJ Platform SDK" />
    <meta property="og:image" content="https://intellij-sdk-docs-cn.github.io/intellij/sdk/docs/jetbrains.png" />
    <meta property="article:modified_time" content="2020-02-19T22:25:03+08:00" />
    <!-- <meta property="article:section" content="" /> 
    <meta property="article:tag" content="" /> -->
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:site" content="@JBPlatform" />
    <meta name="twitter:title" content="XML DOM API" />
    <meta name="twitter:description" content="Documentation for working with and extending the IntelliJ Platform SDK" />
    <meta name="twitter:image" content="https://intellij-sdk-docs-cn.github.io/intellij/sdk/docs/jetbrains.png" />
    <meta class="swiftype" name="product" data-type="string" content="/intellij/sdk/docs/"></meta>
<link  rel="stylesheet" href="/intellij/sdk/docs/app/styles.css"></head>
<body data-id="reference_guide/frameworks_and_external_apis/xml_dom_api">
<div class="wrapper">
    <section class="panel _nav">
        <header class="panel__header">
            <div class="container">
                <form class="search-box">
                    <label for="search-box__input" class="search-box__label">
                        <input type="text" class="search-box__input" id="search-box__input" placeholder="Search IntelliJ Platform SDK  DevGuide">
                    </label>
                    <div class="search-box__clear" title="Clear"></div>
                </form>
            </div>
        </header>
        <nav class="panel__content">
            <div class="container _nav">
                <menu class="nav-tree"></menu>
            </div>
            <div class="container _footer panel__footer">
                <p><a data-bypass="true" href="//youtrack.jetbrains.com/issues/IJSDK">Send feedback</a></p>
                <p>&copy; 2000&ndash;2020 <a href="//www.jetbrains.com">JetBrains</a> s.r.o.<br>
                    All rights reserved.</p>
            </div>
        </nav>
    </section>

    <main class="panel _main" role="main">
        <header class="panel__header">
            <div class="container">
                <h3>IntelliJ Platform SDK DevGuide</h3>
                
                <div class="panel-trigger"></div>
            </div>
        </header>
        <section class="panel__content">
            <div class="container">
                <article class="article" data-shortcut-switcher="false">
                    <div class="navigation-links _top" data-swiftype-index="false">
                        <a class="navigation-links__prev" href="/basics/indexing_and_psi_stubs.html">Indexing and PSI Stubs</a>
                        <a class="navigation-links__next" href="/basics/editing.html">Editing</a>
                    </div>
                    <a data-bypass="true" href="https://github.com/intellij-sdk-docs-cn/intellij-sdk-docs-cn/edit/master/reference_guide/frameworks_and_external_apis/xml_dom_api.md" class="page-link-to-github" target="_blank" title="Edit this page on GitHub">
                        <i class="github-icon"></i>
                        <span class="text">Edit page</span>
                    </a>

                    <h1>XML DOM API</h1>
                    <!-- Copyright 2000-2020 JetBrains s.r.o. and other contributors. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file. -->

<!-- TODO content: DOM <=> PSI, Go To Symbol, editor gutter icon->DOM -->

<a name="abstract" class="elem-anchor"></a>
<h2>Abstract<a href="#abstract" class="anchor-link"><span></span></a></h2>

<p>This article is intended for plugin writers who create custom web server integrations, or some UI for easy XML editing. It describes the <em>Document Object Model</em> (DOM) in IntelliJ Platform — an easy way to work with DTD or Schema-based XML models.
The following topics will be covered: working with DOM itself (reading/writing tags content, attributes, and subtags) and easy XML editing in the UI by connecting UI to DOM.</p>

<p>It’s assumed that the reader is familiar with Java, Swing, IntelliJ Platform XML PSI (classes <a href="https://upsource.jetbrains.com/idea-ce/file/idea-ce-e2d423f42b53eafd5c625b93149a0ebc7e49756c/xml/xml-psi-api/src/com/intellij/psi/xml/XmlTag.java" data-bypass="yes" target="_blank"><span><code class="code highlight language-text">XmlTag</code></span></a>, <a href="https://upsource.jetbrains.com/idea-ce/file/idea-ce-e2d423f42b53eafd5c625b93149a0ebc7e49756c/xml/xml-psi-api/src/com/intellij/psi/xml/XmlFile.java" data-bypass="yes" target="_blank"><span><code class="code highlight language-text">XmlFile</code></span></a>, <a href="https://upsource.jetbrains.com/idea-ce/file/idea-ce-e2d423f42b53eafd5c625b93149a0ebc7e49756c/xml/xml-psi-api/src/com/intellij/psi/xml/XmlTagValue.java" data-bypass="yes" target="_blank"><span><code class="code highlight language-text">XmlTagValue</code></span></a>, etc.), IntelliJ Platform plugin development basics (application and project components, file editors).</p>

<a name="introduction" class="elem-anchor"></a>
<h2>Introduction<a href="#introduction" class="anchor-link"><span></span></a></h2>

<p>So, how to operate with XML from an IntelliJ Platform plugin? Usually, one has to take <code class="code highlight language-text">XmlFile</code>, get its root tag, and then find a required sub-tag by path. The path consists of tag names, each of them a string. Typing these everywhere is tedious and error-prone. Let’s assume you have the following XML:</p>

<div class="code-block" data-lang="xml"><code class="code-block__wrapper"><span class="nt">&lt;root&gt;</span>
    <span class="nt">&lt;foo&gt;</span>
        <span class="nt">&lt;bar&gt;</span>42<span class="nt">&lt;/bar&gt;</span>
        <span class="nt">&lt;bar&gt;</span>239<span class="nt">&lt;/bar&gt;</span>
    <span class="nt">&lt;/foo&gt;</span>
<span class="nt">&lt;/root&gt;</span>
</code></div>

<p>Let’s say you want to read the contents of the second bar element, namely, “239”.</p>

<p>It’s <em>not</em> correct to create chained calls like</p>

<div class="code-block" data-lang="java"><code class="code-block__wrapper"><span class="n">file</span><span class="o">.</span><span class="na">getDocument</span><span class="o">().</span><span class="na">getRootTag</span><span class="o">().</span><span class="na">findFirstSubTag</span><span class="o">(</span><span class="s">"foo"</span><span class="o">).</span>
<span class="n">findSubTags</span><span class="o">(</span><span class="s">"bar"</span><span class="o">)[</span><span class="mi">1</span><span class="o">].</span><span class="na">getValue</span><span class="o">().</span><span class="na">getTrimmedText</span><span class="o">()</span>
</code></div>
<p>because each call here may return <code class="code highlight language-text">null</code>.</p>

<p>So the code would probably look like this:</p>

<div class="code-block" data-lang="java"><code class="code-block__wrapper"><span class="n">XmlFile</span> <span class="n">file</span> <span class="o">=</span> <span class="o">...;</span>
<span class="kd">final</span> <span class="n">XmlDocument</span> <span class="n">document</span> <span class="o">=</span> <span class="n">file</span><span class="o">.</span><span class="na">getDocument</span><span class="o">();</span>
<span class="k">if</span> <span class="o">(</span><span class="n">document</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
    <span class="kd">final</span> <span class="n">XmlTag</span> <span class="n">rootTag</span> <span class="o">=</span> <span class="n">document</span><span class="o">.</span><span class="na">getRootTag</span><span class="o">();</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">rootTag</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">final</span> <span class="n">XmlTag</span> <span class="n">foo</span> <span class="o">=</span> <span class="n">rootTag</span><span class="o">.</span><span class="na">findFirstSubTag</span><span class="o">(</span><span class="s">"foo"</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">foo</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="kd">final</span> <span class="n">XmlTag</span><span class="o">[]</span> <span class="n">bars</span> <span class="o">=</span> <span class="n">foo</span><span class="o">.</span><span class="na">findSubTags</span><span class="o">(</span><span class="s">"bar"</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">bars</span><span class="o">.</span><span class="na">length</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">String</span> <span class="n">s</span> <span class="o">=</span> <span class="n">bars</span><span class="o">[</span><span class="mi">1</span><span class="o">].</span><span class="na">getValue</span><span class="o">().</span><span class="na">getTrimmedText</span><span class="o">();</span>
                <span class="c1">// do something</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></div>

<p>Looks awful, doesn’t it? But there’s a better way to do the same thing. You just need to extend a special interface — <a href="https://upsource.jetbrains.com/idea-ce/file/idea-ce-e2d423f42b53eafd5c625b93149a0ebc7e49756c/xml/dom-openapi/src/com/intellij/util/xml/DomElement.java" data-bypass="yes" target="_blank"><span><code class="code highlight language-text">DomElement</code></span></a>.</p>

<p>For example, let’s create several interfaces:</p>

<div class="code-block" data-lang="java"><code class="code-block__wrapper"><span class="kd">interface</span> <span class="nc">Root</span> <span class="kd">extends</span> <span class="n">com</span><span class="o">.</span><span class="na">intellij</span><span class="o">.</span><span class="na">util</span><span class="o">.</span><span class="na">xml</span><span class="o">.</span><span class="na">DomElement</span> <span class="o">{</span>
    <span class="n">Foo</span> <span class="nf">getFoo</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">interface</span> <span class="nc">Foo</span> <span class="kd">extends</span> <span class="n">com</span><span class="o">.</span><span class="na">intellij</span><span class="o">.</span><span class="na">util</span><span class="o">.</span><span class="na">xml</span><span class="o">.</span><span class="na">DomElement</span> <span class="o">{</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="n">Bar</span><span class="o">&gt;</span> <span class="nf">getBars</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">interface</span> <span class="nc">Bar</span> <span class="kd">extends</span> <span class="n">com</span><span class="o">.</span><span class="na">intellij</span><span class="o">.</span><span class="na">util</span><span class="o">.</span><span class="na">xml</span><span class="o">.</span><span class="na">DomElement</span> <span class="o">{</span>
    <span class="n">String</span> <span class="nf">getValue</span><span class="o">();</span>
<span class="o">}</span>
</code></div>

<p>Next, you should create a <a href="https://upsource.jetbrains.com/idea-ce/file/idea-ce-e2d423f42b53eafd5c625b93149a0ebc7e49756c/xml/dom-openapi/src/com/intellij/util/xml/DomFileDescription.java" data-bypass="yes" target="_blank"><span><code class="code highlight language-text">DomFileDescription</code></span></a> object, pass to its constructor the root tag name and root element interface, and register it with extension point <code class="code highlight language-text">com.intellij.dom.fileDescription</code>.</p>

<aside class="note">
  <p> If your plugin targets 2019.1 or later, please use extension point <code class="code highlight language-text">com.intellij.dom.fileMetaData</code> instead and specify <code class="code highlight language-text">rootTagName</code> and <code class="code highlight language-text">domVersion</code>/<code class="code highlight language-text">stubVersion</code> in <code class="code highlight language-text">plugin.xml</code>.</p>
</aside>

<p>You can now get the file element from <a href="https://upsource.jetbrains.com/idea-ce/file/idea-ce-e2d423f42b53eafd5c625b93149a0ebc7e49756c/xml/dom-openapi/src/com/intellij/util/xml/DomManager.java" data-bypass="yes" target="_blank"><span><code class="code highlight language-text">DomManager</code></span></a>. To get the “239” value, you only have to write the following code:</p>

<div class="code-block" data-lang="java"><code class="code-block__wrapper"><span class="n">DomManager</span> <span class="n">manager</span> <span class="o">=</span> <span class="n">DomManager</span><span class="o">.</span><span class="na">getDomManager</span><span class="o">(</span><span class="n">project</span><span class="o">);</span>
<span class="n">Root</span> <span class="n">root</span> <span class="o">=</span> <span class="n">manager</span><span class="o">.</span><span class="na">getFileElement</span><span class="o">(</span><span class="n">file</span><span class="o">).</span><span class="na">getRootElement</span><span class="o">();</span>
<span class="n">List</span><span class="o">&lt;</span><span class="n">Bar</span><span class="o">&gt;</span> <span class="n">bars</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">getFoo</span><span class="o">().</span><span class="na">getBars</span><span class="o">();</span>
<span class="k">if</span> <span class="o">(</span><span class="n">bars</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">String</span> <span class="n">s</span> <span class="o">=</span> <span class="n">bars</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">1</span><span class="o">).</span><span class="na">getValue</span><span class="o">();</span>
    <span class="c1">// do something</span>
<span class="o">}</span>
</code></div>

<p>I suppose this looks a little bit nicer. You often work with your model in more than one place. Re-creating the model is too inefficient, so we cache it for you, and any subsequent calls to <code class="code highlight language-text">DomManager.getFileElement()</code> will return the same instance. So, it is useful to invoke this method just once, and then keep everywhere only the “root” object you’ve obtained. In this case you wont need to repeat that scary first line, and the code will look even nicer.</p>

<p>It is also important to note that with this scenario we avoid potential <code class="code highlight language-text">NullPointerException</code>: our DOM guarantees that every method accessing a tags child will return a not-null element, even if the correspondingly-named sub-tag doesn’t exist. That may seem strange at a first glance, but it appears to be rather convenient. How does it work? Simple. Given those interfaces, DOM generates all code for accessing correct sub-tags and creating model elements at runtime. The sub-tag names and element types are taken from method names, return types and method annotations, if any. In most cases annotations can be omitted, as in our example, but this is discussed further in this article anyway.</p>

<p>Now let us explore more thoroughly what the DOM can do, and look at possible ways of representing various XML concepts such as tag content, attributes or sub-tags. Later we will discuss basic methods for working with the model, as well as cover more advanced functionality. Finally, we’ll see how to easily create an UI editor for DOM model elements.</p>

<a name="building-the-model" class="elem-anchor"></a>
<h2>Building the Model<a href="#building-the-model" class="anchor-link"><span></span></a></h2>

<a name="tag-content" class="elem-anchor"></a>
<h3>Tag Content<a href="#tag-content" class="anchor-link"><span></span></a></h3>

<p>In XML PSI, tag content is referred to as tag value, so well do the same for consistency. To read and change a tag value, you have to add two methods (getter and setter) to your interface, like this:</p>

<div class="code-block" data-lang="java"><code class="code-block__wrapper"><span class="n">String</span> <span class="nf">getValue</span><span class="o">();</span>
<span class="kt">void</span> <span class="nf">setValue</span><span class="o">(</span><span class="n">String</span> <span class="n">s</span><span class="o">);</span>
</code></div>

<p>These method names (<code class="code highlight language-text">getValue</code> and <code class="code highlight language-text">setValue</code>) are standard, and they are used for accessing tag values by default. If you want to use custom method names for the same goal, you should annotate these methods with <code class="code highlight language-text">@TagValue</code>, for example:</p>

<div class="code-block" data-lang="java"><code class="code-block__wrapper"><span class="nd">@TagValue</span>
<span class="n">String</span> <span class="nf">getTagValue</span><span class="o">();</span>

<span class="nd">@TagValue</span>
<span class="kt">void</span> <span class="nf">setTagValue</span><span class="o">(</span><span class="n">String</span> <span class="n">s</span><span class="o">);</span>
</code></div>

<p>As you can see, our accessors work with <code class="code highlight language-text">String</code> values. This is natural, since XML represents a text format, and tag content is always text. But sometimes you may want to operate with integers, booleans, enums, or even class names (they, of course, will be represented as <code class="code highlight language-text">PsiClass</code>), and more generic Java types (<code class="code highlight language-text">PsiType</code>). In such cases, you just need to change the type in methods to the one you need, and everything will keep working correctly.</p>

<a name="custom-value-types" class="elem-anchor"></a>
<h4>Custom Value Types</h4>

<p>If you operate with even more exotic types, you should tell DOM how to deal with them. First, annotate your accessor methods with the <code class="code highlight language-text">@Convert</code> annotation, and specify your own class that should extend the <code class="code highlight language-text">Converter&lt;T&gt;</code> class in the annotation. Here <code class="code highlight language-text">T</code> is your exotic type, while <code class="code highlight language-text">Converter&lt;T&gt;</code> is a thing that knows how to convert values between <code class="code highlight language-text">String</code> and <code class="code highlight language-text">T</code>. If the value cannot be converted (for example, “foo” is not convertible into <code class="code highlight language-text">Integer</code>), the converter may return <code class="code highlight language-text">null</code>. Please also note that your implementation should have a no-argument constructor.</p>

<p>Let us consider an interesting case when <code class="code highlight language-text">T</code> represents an enum value. Usually, the converter just searches for enum elements with the names specified in XML. But sometimes, for their names, you may need or want to use values that are not valid Java identifiers. For example, CMP version in EJB may be “1.x” or “2.x”, but you can’t create Java enums with such names. For such cases, let your enum implement <code class="code highlight language-text">NamedEnum</code> interface, and then name your enum elements as you wish. Now, just provide the <code class="code highlight language-text">getValue()</code> implementation that will return the right value to match with XML contents, and voilà!
In our example, the code will look as follows:</p>

<div class="code-block" data-lang="java"><code class="code-block__wrapper"><span class="kd">enum</span> <span class="n">CmpVersion</span> <span class="kd">implements</span> <span class="n">NamedEnum</span> <span class="o">{</span>
    <span class="n">CmpVersion_1_X</span> <span class="o">(</span><span class="s">"1.x"</span><span class="o">),</span>
    <span class="n">CmpVersion_2_X</span> <span class="o">(</span><span class="s">"2.x"</span><span class="o">);</span>

    <span class="kd">private</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">value</span><span class="o">;</span>
    
    <span class="kd">private</span> <span class="nf">CmpVersion</span><span class="o">(</span><span class="n">String</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span> 
        <span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span> 
    <span class="o">}</span>

    <span class="kd">public</span> <span class="n">String</span> <span class="nf">getValue</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">value</span><span class="o">;</span> <span class="o">}</span>
<span class="o">}</span>
</code></div>

<p>As we have already mentioned, an XML tag may have lots of artifacts besides its value: there can be attributes, children, but rather often (e.g., according to DTD or Schema) it should have only the value. Of course such tags also need a DOM element to associate with. And we provide such an element:</p>

<div class="code-block" data-lang="java"><code class="code-block__wrapper"><span class="kd">interface</span> <span class="nc">GenericDomValue</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="n">T</span> <span class="nf">getValue</span><span class="o">();</span>
    <span class="kt">void</span> <span class="nf">setValue</span><span class="o">(</span><span class="n">T</span> <span class="n">t</span><span class="o">);</span>

    <span class="nd">@TagValue</span>
    <span class="n">String</span> <span class="nf">getStringValue</span><span class="o">();</span>

    <span class="nd">@TagValue</span>
    <span class="kt">void</span> <span class="nf">setStringValue</span><span class="o">(</span><span class="n">String</span> <span class="n">s</span><span class="o">);</span>
<span class="o">}</span>
</code></div>

<p>So, you can just specify a particular <code class="code highlight language-text">T</code> when using this interface — and everything will work. Methods that work with <code class="code highlight language-text">String</code> are provided for many reasons. For example, your <code class="code highlight language-text">T</code> is <a href="https://upsource.jetbrains.com/idea-ce/file/idea-ce-e2d423f42b53eafd5c625b93149a0ebc7e49756c/java/java-psi-api/src/com/intellij/psi/PsiClass.java" data-bypass="yes" target="_blank"><span><code class="code highlight language-text">PsiClass</code></span></a>. It would be useful to highlight invalid values in UI. To get the value to highlight (the string from the XML file) we have the <code class="code highlight language-text">getStringValue()</code> method. The error message will be taken from the converter via <code class="code highlight language-text">getErrorMessage()</code>.</p>

<a name="attributes" class="elem-anchor"></a>
<h3>Attributes<a href="#attributes" class="anchor-link"><span></span></a></h3>

<p>Attributes are also rather simple to deal with. You can read their values, set them, and operate with different types. So it’s natural to create something like <code class="code highlight language-text">GenericDomValue&lt;T&gt;</code> and then work as usual. “Something like” will be an inheritor, as shown below:</p>

<div class="code-block" data-lang="java"><code class="code-block__wrapper"><span class="kd">interface</span> <span class="nc">GenericAttributeValue</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="n">GenericDomValue</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="n">XmlAttribute</span> <span class="nf">getXmlAttribute</span><span class="o">();</span>
<span class="o">}</span>
</code></div>

<p>Consider that you want to work with an attribute named <em>some-class</em> having a value of type <code class="code highlight language-text">PsiClass</code>:</p>

<div class="code-block" data-lang="java"><code class="code-block__wrapper"><span class="nd">@Attribute</span><span class="o">(</span><span class="s">"some-class"</span><span class="o">)</span>
<span class="n">GenericAttributeValue</span><span class="o">&lt;</span><span class="n">PsiClass</span><span class="o">&gt;</span> <span class="nf">getMyAttributeValue</span><span class="o">();</span>
</code></div>

<p>That’s all! Now you can get/set values, resolve this <code class="code highlight language-text">PsiClass</code>, get its <code class="code highlight language-text">String</code> representation, etc. The name of the attribute will be taken from the method name (see next paragraph). If you name your method in a special way, you can even omit the annotation. For example:</p>

<div class="code-block" data-lang="java"><code class="code-block__wrapper"><span class="n">GenericAttributeValue</span><span class="o">&lt;</span><span class="n">PsiClass</span><span class="o">&gt;</span> <span class="nf">getSomeClass</span><span class="o">();</span>
</code></div>

<p>The <a href="https://upsource.jetbrains.com/idea-ce/file/idea-ce-e2d423f42b53eafd5c625b93149a0ebc7e49756c/xml/dom-openapi/src/com/intellij/util/xml/DomNameStrategy.java" data-bypass="yes" target="_blank"><span><code class="code highlight language-text">DomNameStrategy</code></span></a> interface specifies how to convert accessor names to XML element names. Or more precisely, not the full accessor names, but rather the names minus any “get”, “set” or “is” prefixes. The strategy class is specified in the <code class="code highlight language-text">@NameStrategy</code> annotation in any DOM element interface. Then any descendants and children of this interface will use this strategy. The default strategy is <a href="https://upsource.jetbrains.com/idea-ce/file/idea-ce-e2d423f42b53eafd5c625b93149a0ebc7e49756c/xml/dom-openapi/src/com/intellij/util/xml/HyphenNameStrategy.java" data-bypass="yes" target="_blank"><span><code class="code highlight language-text">HyphenNameStrategy</code></span></a>, where words are delimited by hyphens (see sample above). Another common variant is <a href="https://upsource.jetbrains.com/idea-ce/file/idea-ce-e2d423f42b53eafd5c625b93149a0ebc7e49756c/xml/dom-openapi/src/com/intellij/util/xml/JavaNameStrategy.java" data-bypass="yes" target="_blank"><span><code class="code highlight language-text">JavaNameStrategy</code></span></a> that capitalizes the first letter of each word, as in Java’s naming convention. In our example, the attribute name would be “someClass”.</p>

<p>If attribute doesn’t define a <code class="code highlight language-text">PsiClass</code>, but some other custom <code class="code highlight language-text">T</code> that needs a converter, you just need to specify the <code class="code highlight language-text">@Convert</code> annotation to the getter.</p>

<p>Please note that the attributes getter method will never return <code class="code highlight language-text">null</code>, even if the attribute isn’t specified in XML. Its <code class="code highlight language-text">getValue()</code>, <code class="code highlight language-text">getStringValue()</code> and <code class="code highlight language-text">getXmlAttribute()</code> methods will return <code class="code highlight language-text">null</code>, but the DOM interface instance will exist and be valid. If the element has an underlying attribute, this can be easily fixed (surely, only if you need that): just call the <code class="code highlight language-text">undefine()</code> method (defined in <code class="code highlight language-text">DomElement</code>), and the XML attribute disappears, while <a href="https://upsource.jetbrains.com/idea-ce/file/idea-ce-e2d423f42b53eafd5c625b93149a0ebc7e49756c/xml/dom-openapi/src/com/intellij/util/xml/GenericAttributeValue.java" data-bypass="yes" target="_blank"><span><code class="code highlight language-text">GenericAttributeValue</code></span></a> remains valid.</p>

<a name="children-fixed-number" class="elem-anchor"></a>
<h3>Children: Fixed Number<a href="#children-fixed-number" class="anchor-link"><span></span></a></h3>

<p>You may often deal with tags that have at most one sub-tag with the given name (e.g. <code class="code highlight language-text">&lt;ejb-name&gt;</code>, <code class="code highlight language-text">&lt;ejb-class&gt;</code> or <code class="code highlight language-text">&lt;cmp-field&gt;</code>) in tags defining entity EJBs. To work with such children, provide getters for them. These getters should have a return type that extends <code class="code highlight language-text">DomElement</code>:</p>

<div class="code-block" data-lang="java"><code class="code-block__wrapper"><span class="n">GenericDomValue</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="nf">getEjbName</span><span class="o">();</span>
<span class="n">GenericDomValue</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="nf">getEjbClass</span><span class="o">();</span>
<span class="n">CmpField</span> <span class="nf">getCmpField</span><span class="o">();</span>
</code></div>

<p>There’s also an annotation to designate such children explicitly: <code class="code highlight language-text">@SubTag</code>. Its “value” attribute contains a tag name. If it is not specified, the name is implied from the method name using the current name strategy.</p>

<p>Sometimes it is the sub-tag’s presence that means something, rather than its content — <code class="code highlight language-text">&lt;unchecked&gt;</code> in EJB method permissions, for example. If it exists, then permissions are unchecked, otherwise checked. For such things one should create a special <code class="code highlight language-text">GenericDomValue&lt;Boolean&gt;</code> child. Usually its <code class="code highlight language-text">getValue()</code> returns <code class="code highlight language-text">true</code> if there’s “true” in a tag value, <code class="code highlight language-text">false</code> if there’s “false” in a tag value, and <code class="code highlight language-text">null</code> otherwise. In the <code class="code highlight language-text">@SubTag</code> annotation, you can specify the attribute like <code class="code highlight language-text">indicator=true</code>. In this case, <code class="code highlight language-text">getValue()</code> will return <code class="code highlight language-text">true</code> if the tag exists and <code class="code highlight language-text">false</code> otherwise.</p>

<p>Let’s consider another interesting example inspired by EJB, where there is a relation that has two roles, each designating one relation end: first role and second role. Both are represented by tags with the same values. So, we could create a collection of role elements, and every time we access some role we would check if this collection has sufficient number of elements. But one of the main purposes of the DOM is to eliminate unnecessary checks. So why cant we have a fixed (more than one) number of children with the same tag name? Let’s have them!</p>

<div class="code-block" data-lang="java"><code class="code-block__wrapper"><span class="nd">@SubTag</span><span class="o">(</span><span class="n">value</span> <span class="o">=</span> <span class="s">"ejb-relationship-role"</span><span class="o">,</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="o">)</span>
<span class="n">EjbRelationshipRole</span> <span class="nf">getEjbRelationshipRole1</span><span class="o">();</span>

<span class="nd">@SubTag</span><span class="o">(</span><span class="n">value</span> <span class="o">=</span> <span class="s">"ejb-relationship-role"</span><span class="o">,</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">1</span><span class="o">)</span>
<span class="n">EjbRelationshipRole</span> <span class="nf">getEjbRelationshipRole2</span><span class="o">();</span>
</code></div>

<p>The first method will return the DOM element for the first subtag named <code class="code highlight language-text">&lt;ejb-relationship-role&gt;</code>, and the second — for the second one. Hence the term “fixed-number” for such children. According to DTD or Schema, there should be fixed number of subtags with the given name. Most often this fixed number is 1; in our case with the relations it is 2. Just like attributes, fixed-number children exist regardless of underlying tag existence. If you need to delete tags, it can be done with the help of the same <code class="code highlight language-text">undefine()</code> method.</p>

<p>For children of <a href="https://upsource.jetbrains.com/idea-ce/file/idea-ce-e2d423f42b53eafd5c625b93149a0ebc7e49756c/xml/dom-openapi/src/com/intellij/util/xml/GenericDomValue.java" data-bypass="yes" target="_blank"><span><code class="code highlight language-text">GenericDomValue</code></span></a> type, you can also specify a converter, just as you can for attributes.</p>

<a name="children-collections" class="elem-anchor"></a>
<h3>Children: Collections<a href="#children-collections" class="anchor-link"><span></span></a></h3>

<p>One more common case in DTD and Schemas is when children have the same tag name and a non-fixed upper limit in count. Their accessors differ from those of the fixed-number children in the following: the return result is <code class="code highlight language-text">Collection</code> or <code class="code highlight language-text">List</code> of a special type that extends <code class="code highlight language-text">DomElement</code>, and if you want to use name strategies, the method name must be in pluralized form. For example, in EJB we would have the following method:</p>

<div class="code-block" data-lang="java"><code class="code-block__wrapper"><span class="n">List</span><span class="o">&lt;</span><span class="n">Entity</span><span class="o">&gt;</span> <span class="nf">getEntities</span><span class="o">();</span>
</code></div>
<p>There’s also an annotation <code class="code highlight language-text">@SubTagList</code> where you can explicitly specify the tag name.</p>

<p>Returned collections cannot be modified directly. To delete an element from collection, just call <code class="code highlight language-text">undefine()</code> on this element. The tag will then be removed, and element will become invalid (<code class="code highlight language-text">DomElement.isValid() == false</code>). Note that this behavior differs from that of fixed-number children and attributes: they are always valid, even after <code class="code highlight language-text">undefine()</code>. Again, unlike those children types, collection children always have valid underlying XML tags.</p>

<p>Adding elements is a little bit harder. Since all DOM elements are created internally, you can’t just pass some of your DOM elements to some method, to add the element to the collection. In fact, you have to ask a parent element to add a child to the collection. In our example it’s done in the following way:</p>

<div class="code-block" data-lang="java"><code class="code-block__wrapper"><span class="n">Entity</span> <span class="nf">addEntity</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">);</span>
</code></div>

<p>which adds an element to wherever you want, or</p>

<div class="code-block" data-lang="java"><code class="code-block__wrapper"><span class="n">Entity</span> <span class="nf">addEntity</span><span class="o">();</span>
</code></div>
<p>which adds a new DOM element to the end of the collection. Please note the singular tense of the word “Entity”. That’s because here we deal with one <code class="code highlight language-text">Entity</code> object, while in the collection getter we dealt with potentially many entities.</p>

<p>Now, you can do anything you want with the returned value: modify, define the tag’s value, children, etc.</p>

<p>The last common case is also a collection, but one consisting of tags with different names that are arbitrarily mixed. To work with it, you should define collection getters for all tag names within the mixed collection, and then define an additional specially annotated getter:</p>

<div class="code-block" data-lang="java"><code class="code-block__wrapper"><span class="c1">// &lt;foo&gt; elements</span>
<span class="n">List</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span> <span class="nf">getFoos</span><span class="o">();</span>

<span class="c1">// &lt;bar&gt; elements</span>
<span class="n">List</span><span class="o">&lt;</span><span class="n">Bar</span><span class="o">&gt;</span> <span class="nf">getBars</span><span class="o">();</span>

<span class="c1">// all &lt;foo&gt; and &lt;bar&gt; elements</span>
<span class="nd">@SubTagsList</span><span class="o">({</span><span class="s">"foo"</span><span class="o">,</span> <span class="s">"bar"</span><span class="o">})</span>
<span class="n">List</span><span class="o">&lt;</span><span class="n">FooBar</span><span class="o">&gt;</span> <span class="nf">getMergedListOfFoosAndBars</span><span class="o">();</span>
</code></div>
<p>The annotation here is mandatory - we cannot guess several tag names from one method name.</p>

<p>To add elements to such mixed collections, you should create “add” methods for each possible tag name:</p>

<div class="code-block" data-lang="java"><code class="code-block__wrapper"><span class="nd">@SubTagsList</span><span class="o">(</span><span class="n">value</span><span class="o">={</span><span class="s">"foo"</span><span class="o">,</span><span class="s">"bar"</span><span class="o">},</span> <span class="n">tagName</span><span class="o">=</span><span class="s">"foo"</span><span class="o">)</span> <span class="n">Fubar</span> <span class="nf">addFoo</span><span class="o">();</span>
<span class="nd">@SubTagsList</span><span class="o">(</span><span class="n">value</span><span class="o">={</span><span class="s">"foo"</span><span class="o">,</span><span class="s">"bar"</span><span class="o">},</span> <span class="n">tagName</span><span class="o">=</span><span class="s">"bar"</span><span class="o">)</span> <span class="n">Fubar</span> <span class="nf">addBar</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">);</span>
</code></div>
<p>The index parameter in the last example means the index in the merged collection, not in the collection of tags named “bar”.</p>

<a name="dynamic-definition" class="elem-anchor"></a>
<h3>Dynamic Definition<a href="#dynamic-definition" class="anchor-link"><span></span></a></h3>
<p>You can extend existing DOM model at runtime by implementing <code class="code highlight language-text">com.intellij.util.xml.reflect.DomExtender&lt;T&gt;</code>. Register it in “extenderClass” attribute of EP <code class="code highlight language-text">com.intellij.dom.extender</code>, where “domClass” specifies DOM class <code class="code highlight language-text">&lt;T&gt;</code> to be extended. <a href="https://upsource.jetbrains.com/idea-ce/file/idea-ce-e2d423f42b53eafd5c625b93149a0ebc7e49756c/xml/dom-openapi/src/com/intellij/util/xml/reflect/DomExtensionsRegistrar.java" data-bypass="yes" target="_blank"><span><code class="code highlight language-text">DomExtensionsRegistrar</code></span></a> provides various methods to register dynamic attributes and children.</p>

<p>If the contributed elements depend on anything other than plain XML file content (used framework version, libraries in classpath, …), make sure to return <code class="code highlight language-text">false</code> from <code class="code highlight language-text">DomExtender.supportsStubs()</code>.</p>

<a name="generating-dom-from-existing-xsd" class="elem-anchor"></a>
<h3>Generating DOM from existing XSD<a href="#generating-dom-from-existing-xsd" class="anchor-link"><span></span></a></h3>
<p>DOM can be generated automatically from existing XSD/DTD. Output correctness/completeness will largely depend on the input scheme and may require additional manual adjustments.</p>

<p>Follow these steps:</p>

<ul>
  <li>Run IntelliJ IDEA with <em>Plugin DevKit</em> enabled in <a href="/intellij/sdk/docs/reference_guide/internal_actions/enabling_internal.html"><span>internal mode</span></a></li>
  <li>Select <em>Tools | Internal Actions | DevKit | Generate DOM Model</em></li>
  <li>Select Scheme file and set options, then click “Generate” to generate sources</li>
  <li>Modify generated sources according to your needs</li>
</ul>

<a name="ide-support" class="elem-anchor"></a>
<h3>IDE support<a href="#ide-support" class="anchor-link"><span></span></a></h3>
<p><em>Plugin DevKit</em> supports the following features for working with DOM related code:</p>

<ul>
  <li><a href="https://upsource.jetbrains.com/idea-ce/file/idea-ce-e2d423f42b53eafd5c625b93149a0ebc7e49756c/xml/dom-openapi/src/com/intellij/util/xml/DomElement.java" data-bypass="yes" target="_blank"><span><code class="code highlight language-text">DomElement</code></span></a> - provide implicit usages for all DOM-related methods defined in inheriting classes (to suppress “unused method” warning)</li>
  <li><a href="https://upsource.jetbrains.com/idea-ce/file/idea-ce-e2d423f42b53eafd5c625b93149a0ebc7e49756c/xml/dom-openapi/src/com/intellij/util/xml/DomElementVisitor.java" data-bypass="yes" target="_blank"><span><code class="code highlight language-text">DomElementVisitor</code></span></a> - provide implicit usages for all DOM-related visitor methods defined in inheriting classes (to suppress “unused method” warning)</li>
</ul>

<a name="working-with-the-dom" class="elem-anchor"></a>
<h2>Working with the DOM<a href="#working-with-the-dom" class="anchor-link"><span></span></a></h2>

<a name="class-choosers" class="elem-anchor"></a>
<h3>Class Choosers<a href="#class-choosers" class="anchor-link"><span></span></a></h3>
<p>It often happens that a collection contains same-named tags that may have different structure or even be represented by different types in the DTD or Schema. As an example, JSF Managed Beans may be of three types. If a <code class="code highlight language-text">&lt;managed-bean&gt;</code> tag contains a <code class="code highlight language-text">&lt;map-entries&gt;</code> sub-tag, then the Managed Bean type is <code class="code highlight language-text">MapEntriesBean</code>. If it contains a <code class="code highlight language-text">&lt;list-entries&gt;</code> sub-tag — can you guess? Right — <code class="code highlight language-text">ListEntriesBean</code>! Otherwise it’s a <code class="code highlight language-text">PropertyBean</code> (all three interfaces extend <code class="code highlight language-text">ManagedBean</code>). And when we write <code class="code highlight language-text">List&lt;ManagedBean&gt; getManagedBeans()</code>, we expect to get not only a list where all elements are instances of the <code class="code highlight language-text">ManagedBean</code> interface, but a list where each element is of a certain type, i.e. <code class="code highlight language-text">MapEntriesBean</code>, <code class="code highlight language-text">ListEntriesBean</code>, or <code class="code highlight language-text">PropertyBean</code>.</p>

<p>In such cases one should decide which interface the DOM element should actually implement (according to the given tag). This is achieved by extending the <a href="https://upsource.jetbrains.com/idea-ce/file/idea-ce-e2d423f42b53eafd5c625b93149a0ebc7e49756c/xml/dom-openapi/src/com/intellij/util/xml/TypeChooser.java" data-bypass="yes" target="_blank"><span><code class="code highlight language-text">TypeChooser</code></span></a> abstract class:</p>

<div class="code-block" data-lang="java"><code class="code-block__wrapper"><span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">TypeChooser</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="n">Type</span> <span class="nf">chooseType</span><span class="o">(</span><span class="n">XmlTag</span> <span class="n">tag</span><span class="o">);</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">distinguishTag</span><span class="o">(</span><span class="n">XmlTag</span> <span class="n">tag</span><span class="o">,</span> <span class="n">Type</span> <span class="n">aClass</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IncorrectOperationException</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="n">Type</span><span class="o">[]</span> <span class="nf">getChooserTypes</span><span class="o">();</span>
<span class="o">}</span>
</code></div>

<p>Here, the first method (<code class="code highlight language-text">chooseType()</code>) does exactly what it is named after (chooses the particular type, most often it’s a class). The second one (<code class="code highlight language-text">distinguishTag()</code>) acts in reverse: it modifies a tag so that when the element is read from an XML file next time (for example, after the user has closed and opened the project again), the newly created DOM element will implement the same interface and no model data will be lost. Finally, <code class="code highlight language-text">getChooserTypes()</code> just returns all the types that could be returned by <code class="code highlight language-text">chooseType()</code>.</p>

<p>To make your <code class="code highlight language-text">TypeChooser</code> work, register it in your overridden <code class="code highlight language-text">DomFileDescription.initializeFileDescription()</code> method by calling <code class="code highlight language-text">registerTypeChooser()</code>.</p>

<a name="useful-methods-of-domelement-and-dommanager" class="elem-anchor"></a>
<h3>Useful Methods of DomElement and DomManager<a href="#useful-methods-of-domelement-and-dommanager" class="anchor-link"><span></span></a></h3>

<a name="psi-connection" class="elem-anchor"></a>
<h4>PSI Connection</h4>
<p>Of course, DOM is tightly connected to XML PSI, so there’s always a way of getting the <code class="code highlight language-text">XmlTag</code> instance (which can be <code class="code highlight language-text">null</code> for fixed-number children and attributes) using the <code class="code highlight language-text">getXmlTag()</code> method. We remember that in <code class="code highlight language-text">GenericAttributeValue</code> there’s also the <code class="code highlight language-text">getXmlAttribute()</code> method. In general case there is <code class="code highlight language-text">getXmlElement()</code> method. You can also get a DOM element by its underlying XML PSI element using the <code class="code highlight language-text">DomManager.getDomElement()</code> method.</p>

<p>If DOM element has no underlying XML element, it can be created by calling <code class="code highlight language-text">ensureTagExists()</code>. To delete a tag, use the already known <code class="code highlight language-text">undefine()</code> method. This method will always delete the underlying XML element (tag or attribute). If the element was a collection child, then neither it nor its entire sub-tree will be valid anymore.</p>

<a name="tree-structure" class="elem-anchor"></a>
<h4>Tree Structure</h4>
<p>In every normal tree there’s always a possibility to walk up. <code class="code highlight language-text">DomElement</code> is no exception. Method <code class="code highlight language-text">getParent()</code> just returns element’s parent in tree.</p>

<p>The method <code class="code highlight language-text">&lt;T extends DomElement&gt; T getParentOfType(Class&lt;T&gt; requiredClass, boolean strict)</code> returns the tree ancestor of the given class. You can see the standard <em>strict</em> parameter, that can return the DOM element itself, if it’s <code class="code highlight language-text">false</code> and your current DOM element is an instance of <em>requiredClass</em>.</p>

<p>Finally, <code class="code highlight language-text">getRoot()</code> will return the <code class="code highlight language-text">DomFileElement</code>, which is the root of every DOM tree.</p>

<a name="validity" class="elem-anchor"></a>
<h4>Validity</h4>
<p>An element becomes invalid if it has been deleted explicitly or due to external PSI changes. Fixed-number children and attributes are meant to stay valid as long as possible, no matter what happens with XML. They can become invalid only if they have collection tree ancestor that has been deleted.</p>

<p>Newly created DOM elements are always correct and valid, so their <code class="code highlight language-text">isValid()</code> methods will return <code class="code highlight language-text">true</code>.</p>

<p>Element validity is very important, since you cannot invoke any methods on invalid elements (except, of course, <code class="code highlight language-text">isValid()</code> itself).</p>

<a name="dom-reflection" class="elem-anchor"></a>
<h4>DOM Reflection</h4>
<p>DOM also has a kind of reflection, called “Generic Info”. One would use it to be able to access children by tag names directly, instead of calling getter methods. See <a href="https://upsource.jetbrains.com/idea-ce/file/idea-ce-e2d423f42b53eafd5c625b93149a0ebc7e49756c/xml/dom-openapi/src/com/intellij/util/xml/reflect/DomGenericInfo.java" data-bypass="yes" target="_blank"><span><code class="code highlight language-text">DomGenericInfo</code></span></a> interface and <code class="code highlight language-text">getGenericInfo()</code> methods in <code class="code highlight language-text">DomElement</code> and <code class="code highlight language-text">DomManager</code> for more information. There’s also <code class="code highlight language-text">DomElement.getXmlElementName()</code> method that returns the name of a corresponding tag or attribute.</p>

<a name="presentation" class="elem-anchor"></a>
<h4>Presentation</h4>
<!-- TODO: using @Presentation -->

<p><code class="code highlight language-text">DomElement.getPresentation()</code> returns an instance of <a href="https://upsource.jetbrains.com/idea-ce/file/idea-ce-e2d423f42b53eafd5c625b93149a0ebc7e49756c/xml/dom-openapi/src/com/intellij/util/xml/ElementPresentation.java" data-bypass="yes" target="_blank"><span><code class="code highlight language-text">ElementPresentation</code></span></a>, an interface that knows presentable element type, name, and sometimes even its icon. Presentations are actually obtained from presentation factory objects that, like ClassChoosers’s, should be registered in <a href="https://upsource.jetbrains.com/idea-ce/file/idea-ce-e2d423f42b53eafd5c625b93149a0ebc7e49756c/xml/dom-openapi/src/com/intellij/util/xml/ElementPresentationManager.java" data-bypass="yes" target="_blank"><span><code class="code highlight language-text">ElementPresentationManager</code></span></a> as early as possible. You can specify type name and icon for all elements of some class, ways of getting type name, icon and presentable name for particular objects. When not specified, presentable name is taken from the object itself, if it contains a method annotated with <code class="code highlight language-text">@NameValue</code> annotation, that returns <code class="code highlight language-text">String</code> or <code class="code highlight language-text">GenericValue</code>. If there’s no such method, it will return <code class="code highlight language-text">null</code>. For <code class="code highlight language-text">DomElement</code>, there’s another way to get this presentable name: 
<code class="code highlight language-text">DomElement.getGenericInfo().getElementName()</code>.</p>

<a name="events" class="elem-anchor"></a>
<h4>Events</h4>
<p>If you want to be notified on every change in the DOM model, add <code class="code highlight language-text">DomEventListener</code> to <code class="code highlight language-text">DomManager</code>. DOM supports the following events: tag value changed, element defined/undefined/changed, and collection child added/removed.</p>

<a name="highlighting-annotations" class="elem-anchor"></a>
<h4>Highlighting Annotations</h4>
<p>The DOM supports error checking and highlighting. It’s based on annotations which you add to the DOM element in a special place (don’t confuse these annotations with the ones of Java 5 — they are very different). You need to implement the <a href="https://upsource.jetbrains.com/idea-ce/file/idea-ce-e2d423f42b53eafd5c625b93149a0ebc7e49756c/xml/dom-openapi/src/com/intellij/util/xml/highlighting/DomElementsAnnotator.java" data-bypass="yes" target="_blank"><span><code class="code highlight language-text">DomElementAnnotator</code></span></a> interface, and override <code class="code highlight language-text">DomFileDescription.createAnnotator()</code> method, and create this annotator there. In <code class="code highlight language-text">DomElementsAnnotator.annotate(DomElement element, DomElementsProblemsHolder annotator)</code> you should report about all errors and warnings in the element’s sub-tree to the annotator (<code class="code highlight language-text">DomElementsProblemsHolder.createProblem()</code>). You should return this annotator in the corresponding virtual method of the <code class="code highlight language-text">DomFileDescription</code>.</p>

<a name="automatic-highlighting-basicdomelementsinspection" class="elem-anchor"></a>
<h4>Automatic highlighting (BasicDomElementsInspection)</h4>
<p>The following errors can be highlighted automatically by providing an instance of <code class="code highlight language-text">BasicDomElementsInspection</code>:</p>

<ul>
  <li><code class="code highlight language-text">@Required</code> element missing or having empty text</li>
  <li>XML value cannot be converted by some <code class="code highlight language-text">Converter</code></li>
  <li>name is not unique while it should be</li>
</ul>

<p>The latter case requires you to specify the name getter with <code class="code highlight language-text">@NameValue</code> annotation. The checking uses the <code class="code highlight language-text">DomFileDescription.getIdentityScope()</code> method to get the element defining the root scope in which the name should be unique.</p>

<p>To suppress spellchecking annotate your DomElement with <code class="code highlight language-text">@com.intellij.spellchecker.xml.NoSpellchecking</code>.</p>

<a name="required-children" class="elem-anchor"></a>
<h4>Required Children</h4>
<p>There is a common case in error highlighting, when one needs to say, that some required sub-tag or attribute is missing. DOM will do this for you automatically, if you annotate the getter for that child with the <code class="code highlight language-text">@Required</code> annotation. For collection children getters, this annotation will mean, that the collection should be not empty (corresponding to ‘+’ sign in DTD). Also, when you create a new element that has required fixed-number or attribute children, their tags or attributes will also be created in XML.</p>

<a name="resolving" class="elem-anchor"></a>
<h3>Resolving<a href="#resolving" class="anchor-link"><span></span></a></h3>
<p>Remember the interface <code class="code highlight language-text">GenericDomValue&lt;T&gt;</code> and its sub-interface <code class="code highlight language-text">GenericAttributeValue&lt;T&gt;</code>? Remember, that ANY class may be passed as <code class="code highlight language-text">T</code> — for example, let’s interpret <code class="code highlight language-text">GenericDomValue&lt;PsiClass&gt;</code> as a reference to a class. Then we can always consider it as a reference to an object of class <code class="code highlight language-text">T</code>! With Strings or enums, it is not a very useful idea, but we’ll use it in another way. Very often XML has such a structure that an object is declared at some place, and is referenced at some other place (more precisely, in a tag or attribute value). So, if you want to create a method like <code class="code highlight language-text">GenericValue&lt;MyDomElement&gt; getMyDomElementReference()</code>, then you just have to specify a proper converter that will find an instance in your model of <code class="code highlight language-text">MyDomElement</code> with the name specified in the <code class="code highlight language-text">GenericDomValue</code>.</p>

<p>That’s the core idea. Since creating such converters is quite boring, we’ve done it for you. You don’t have to annotate reference getters at all, as the name resolution will be made automatically. Elements will be searched by name, and the name will be taken from the method annotated with <code class="code highlight language-text">@NameValue</code>. The converter used is <a href="https://upsource.jetbrains.com/idea-ce/file/idea-ce-e2d423f42b53eafd5c625b93149a0ebc7e49756c/xml/dom-openapi/src/com/intellij/util/xml/DomResolveConverter.java" data-bypass="yes" target="_blank"><span><code class="code highlight language-text">DomResolveConverter</code></span></a>. Its constructor takes a parameter, so it can’t be referenced in <code class="code highlight language-text">@Convert</code> annotation, but its subclasses (if you create them) — can. If you still want to specify explicitly that your reference to <code class="code highlight language-text">DomElement</code> should be resolved “model-wide”, use the <code class="code highlight language-text">@Resolve</code> annotation parameterized with the desired class. The resolution scope will be taken from the <code class="code highlight language-text">DomFileDescription.getResolveScope()</code>.</p>

<p>In addition to the above, auto-resolving in DOM also provides some features in your XML text editor: error highlighting, completion, Find Usages, Rename Refactoring… Unresolved references will be highlighted, and even completed. If you want to create a custom converter and want to have this code insight with it, you should extend not only the <a href="https://upsource.jetbrains.com/idea-ce/file/idea-ce-e2d423f42b53eafd5c625b93149a0ebc7e49756c/xml/dom-openapi/src/com/intellij/util/xml/Converter.java" data-bypass="yes" target="_blank"><span><code class="code highlight language-text">Converter</code></span></a> but <a href="https://upsource.jetbrains.com/idea-ce/file/idea-ce-e2d423f42b53eafd5c625b93149a0ebc7e49756c/xml/dom-openapi/src/com/intellij/util/xml/ResolvingConverter.java" data-bypass="yes" target="_blank"><span><code class="code highlight language-text">ResolvingConverter</code></span></a>. It has one more method <code class="code highlight language-text">getVariants()</code>, where you’ll have to provide the collection consisting of all targets your reference may resolve to. Those familiar with <a href="https://upsource.jetbrains.com/idea-ce/file/idea-ce-e2d423f42b53eafd5c625b93149a0ebc7e49756c/platform/core-api/src/com/intellij/psi/PsiReference.java" data-bypass="yes" target="_blank"><span><code class="code highlight language-text">PsiReference</code></span></a> will recognize the similarities here.</p>

<p>If you need to choose a <code class="code highlight language-text">Converter</code> depending on other values (e.g. in sibling/parent element) or any runtime condition (e.g. presence or version of library), you can use <code class="code highlight language-text">WrappingConverter</code>. See also <code class="code highlight language-text">GenericDomValueConvertersRegistry</code> for managing an extensible registry of available Converters to choose from.</p>

<a name="mock-and-stable-elements" class="elem-anchor"></a>
<h3>Mock and Stable Elements<a href="#mock-and-stable-elements" class="anchor-link"><span></span></a></h3>
<p>Your DOM elements do not have to be tied to a physical file. <code class="code highlight language-text">DomManager.createMockElement()</code> will help you to create a virtual element of a given class with the given module. An element may be physical or not. ‘Physical’ here means that DOM will create a mock document for it, so you can enjoy Undo functionality if you pass this document to the right place in file editor.</p>

<p><code class="code highlight language-text">DomElement.copyFrom()</code> allows you to copy information from one <code class="code highlight language-text">DomElement</code> to another. In fact, it just replaces XML tags, and all the old data is lost. Nevertheless, the element’s fixed-number children don’t become invalid, they only contain new tag values, attribute values, etc. The tree is actually rather conservative.</p>

<p>The combination of <code class="code highlight language-text">createMockElement()</code> and <code class="code highlight language-text">copyFrom()</code> is useful for editing element contents in dialogs. You create a mock copy of an element, work with it in the dialog and then, if the user doesn’t cancel, copy the element back to the main model. Since it’s a common case, a special shortcut method has been created in <code class="code highlight language-text">DomElement</code>, called <code class="code highlight language-text">createMockCopy()</code>.</p>

<p>IntelliJ Platform’s XML parser is incremental: changes in text do not cause the whole file to be reparsed. But you should keep in mind that this rule may sometimes not work correctly. For example, your DOM elements can unexpectedly become broken as a result of manual editing of the XML file (even if it didn’t happen inside those elements). If a file editor depends on such a broken element, this can lead to closing the tab, which isn’t very nice from the user’s point of view. For example, suppose you have an entity bean named “SomeEntity”. You open an editor for it, then you go into the XML, change the tag name from entity to session, and then back to entity. Of course, no DOM element can survive after such blasphemy. But notwithstanding, you still want your editor to stay open! Well, there is a solution, and it’s called <code class="code highlight language-text">DomManager.createStableValue(Factory factory)</code>.
This method creates a DOM element that delegates all its functionality to some real element (returned from the factory parameter). As soon as that real element becomes invalid, the factory is called once more, and if it returns something valid, it becomes the new delegate. And so on… In the example with EJB, the factory would once again look for an Entity Bean named “SomeEntity”.</p>

<p>Stable DOM elements also implement the <code class="code highlight language-text">StableElement</code> interface, which has the following methods:</p>

<ul>
  <li><code class="code highlight language-text">DomElement getWrappedElement()</code> — just returns the current element to which all method calls are delegated;</li>
  <li><code class="code highlight language-text">void invalidate()</code> — makes the wrapped element invalid. Any following method call will cause the factory to create a new delegate;</li>
  <li><code class="code highlight language-text">void revalidate()</code> — calls the factory, and if it returns something new (i.e. not the same as the current wrapped element) invalidates the old value and adopts the new one.</li>
</ul>

<a name="visitor" class="elem-anchor"></a>
<h3>Visitor<a href="#visitor" class="anchor-link"><span></span></a></h3>
<p>Visitor is a very common design pattern. DOM model also has a visitor, and it’s called <code class="code highlight language-text">DomElementVisitor</code>. The <code class="code highlight language-text">DomElement</code> interface has methods <code class="code highlight language-text">accept()</code> and <code class="code highlight language-text">acceptChildren()</code> that take this visitor as a parameter. If you look at the interface <code class="code highlight language-text">DomElementVisitor</code> itself, you may be surprised, since it has only one method: <code class="code highlight language-text">visitDomElement(DomElement)</code>. Where is the Visitor pattern? Where are all those methods with names like <code class="code highlight language-text">visitT(T)</code> that are usually found in it? There are no such methods, because the actual interfaces (T’s) aren’t known to anyone except you. But when you instantiate the <code class="code highlight language-text">DomElementVisitor</code> interface, you may add there these <code class="code highlight language-text">visitT()</code> methods, and they will be called! You may even name them just <code class="code highlight language-text">visit()</code>, specify the type of the parameter, and everything will be fine. For example, if you have two DOM element classes — <code class="code highlight language-text">Foo</code> and <code class="code highlight language-text">Bar</code> — your visitor may look like this:</p>

<div class="code-block" data-lang="java"><code class="code-block__wrapper"><span class="kd">class</span> <span class="nc">MyVisitor</span> <span class="kd">implements</span> <span class="n">DomElementVisitor</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">visitDomElement</span><span class="o">(</span><span class="n">DomElement</span> <span class="n">element</span><span class="o">)</span> <span class="o">{}</span>
    <span class="kt">void</span> <span class="nf">visitFoo</span><span class="o">(</span><span class="n">Foo</span> <span class="n">foo</span><span class="o">)</span> <span class="o">{}</span>
    <span class="kt">void</span> <span class="nf">visitBar</span><span class="o">(</span><span class="n">Bar</span> <span class="n">bar</span><span class="o">)</span> <span class="o">{}</span>
<span class="o">}</span>
</code></div>

<a name="implementation" class="elem-anchor"></a>
<h3>Implementation<a href="#implementation" class="anchor-link"><span></span></a></h3>
<p>Sometimes you may want to extend your model with some functionality that isn’t directly connected with XML, but relates to your program logic. And the most appropriate place for this functionality is the DOM element interface. What to do then?</p>

<p>The simplest case is when you want to add to your interface a method that returns exactly what some other getter in this element (or in one of its children) returns. You can easily write this helper method and annotate it with the <code class="code highlight language-text">@PropertyAccessor</code> annotation, in which you should specify the path consisting of property names (getter names without the “get” or “is” prefixes). For example, you can write:</p>

<div class="code-block" data-lang="java"><code class="code-block__wrapper"><span class="n">GenericDomValue</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="nf">getVeryLongName</span><span class="o">()</span>

<span class="nd">@PropertyAccessor</span><span class="o">(</span><span class="s">"very-long-name"</span><span class="o">)</span>
<span class="n">GenericDomValue</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="nf">getName</span><span class="o">()</span>
</code></div>
<p>In this case, the second method will return just the same as the first one. If there were “foo.bar.name” instead of “very-long-name” in the annotation, the system would actually call <code class="code highlight language-text">getFoo().getBar().getName()</code> and return the result to you. Such annotations are useful when you’re extending some interface that is inconsistent with your model, or you try to extract a common super-interface from two model interfaces with differently named children that have the same sense (see <code class="code highlight language-text">&lt;ejb-ref&gt;</code> and <code class="code highlight language-text">&lt;ejb-local-ref&gt;</code>).</p>

<p>The case just described is simple, but rare. More often, you really have to incorporate some logic into your model. Then nothing except Java code helps you. And it will. Add the desired methods to your interface, then create an abstract class implementing the interface, and implement there only methods that you added manually and that are not directly connected to your XML model. Note that the class should have a constructor with no arguments.</p>

<p>Now you only have to let DOM know that you wish to use this implementation every time you’re creating a model element that should implement the necessary interface. Simply register it using
extension point <code class="code highlight language-text">com.intellij.dom.implementation</code> and DOM will generate at run-time the class that not only implements the needed interface, but also extends your abstract class.</p>

<a name="models-across-multiple-files" class="elem-anchor"></a>
<h3>Models across multiple files<a href="#models-across-multiple-files" class="anchor-link"><span></span></a></h3>
<p>Many frameworks require a set of XML configuration files (“fileset”) to work as one model, so resolving/navigation works across all related DOM files.
Depending on implementation/plugin, providing filesets implicitly (using existing framework’s setup in project) or via user configuration (usually via dedicated <code class="code highlight language-text">Facet</code>) can be achieved.</p>

<p>Extend <a href="https://upsource.jetbrains.com/idea-ce/file/idea-ce-e2d423f42b53eafd5c625b93149a0ebc7e49756c/xml/dom-openapi/src/com/intellij/util/xml/model/impl/DomModelFactory.java" data-bypass="yes" target="_blank"><span><code class="code highlight language-text">DomModelFactory</code></span></a> (or <a href="https://upsource.jetbrains.com/idea-ce/file/idea-ce-e2d423f42b53eafd5c625b93149a0ebc7e49756c/xml/dom-openapi/src/com/intellij/util/xml/model/impl/BaseDomModelFactory.java" data-bypass="yes" target="_blank"><span><code class="code highlight language-text">BaseDomModelFactory</code></span></a> for non-<code class="code highlight language-text">Module</code> scope) and provide implementation of your <code class="code highlight language-text">DomModel</code>. Usually you will want to add searcher/utility methods to work with your <code class="code highlight language-text">DomModel</code> implementation.
Example can be found in Struts 2 plugin (package <code class="code highlight language-text">com.intellij.struts2.dom.struts.model</code>).</p>

<a name="dom-stubs" class="elem-anchor"></a>
<h3>DOM Stubs<a href="#dom-stubs" class="anchor-link"><span></span></a></h3>
<aside class="note">
  <p> Please use it sparingly and only for heavily accessed parts in your DOM model, as it increases disk space usage/indexing run time.</p>
</aside>

<p>DOM elements can be stubbed, so (costly) access to XML/PSI is not necessary (see <a href="/intellij/sdk/docs/basics/indexing_and_psi_stubs.html"><span>Indexing and PSI Stubs</span></a> for similar feature for custom languages). Performance relevant elements, tag or attribute getters can simply be annotated with <code class="code highlight language-text">@com.intellij.util.xml.Stubbed</code>.
Return <code class="code highlight language-text">true</code> from <code class="code highlight language-text">DomFileDescription.hasStubs()</code> and increase <code class="code highlight language-text">DomFileDescription.getStubVersion()</code> whenever you change <code class="code highlight language-text">@Stubbed</code> annotations usage in your DOM hierarchy to trigger proper rebuilding of Stubs during indexing.</p>

<a name="building-a-dom-based-gui" class="elem-anchor"></a>
<h2>Building a DOM-based GUI<a href="#building-a-dom-based-gui" class="anchor-link"><span></span></a></h2>

<a name="forms" class="elem-anchor"></a>
<h3>Forms<a href="#forms" class="anchor-link"><span></span></a></h3>
<p>All forms that deal with DOM are organized in a special way. They support two main things: getting data from XML into the UI, and saving UI data to XML. The former is called resetting, the latter — committing. There’s <a href="https://upsource.jetbrains.com/idea-ce/file/idea-ce-e2d423f42b53eafd5c625b93149a0ebc7e49756c/xml/dom-openapi/src/com/intellij/util/xml/ui/Committable.java" data-bypass="yes" target="_blank"><span><code class="code highlight language-text">Committable</code></span></a> interface that has corresponding methods: <code class="code highlight language-text">commit()</code> and <code class="code highlight language-text">reset()</code>. There’s also a way of structuring your forms into smaller parts, namely the Composite pattern: <a href="https://upsource.jetbrains.com/idea-ce/file/idea-ce-e2d423f42b53eafd5c625b93149a0ebc7e49756c/xml/dom-openapi/src/com/intellij/util/xml/ui/CompositeCommittable.java" data-bypass="yes" target="_blank"><span><code class="code highlight language-text">CompositeCommittable</code></span></a>. Methods <code class="code highlight language-text">commit()</code> and <code class="code highlight language-text">reset()</code> are invoked automatically on editor tab switch or undo. So you only need to ensure that all your Swing structure is organized in a tree of <code class="code highlight language-text">CompositeCommittable</code>, and all the hard work will be done by the IDE.</p>

<p>DOM controls are special descendants of <code class="code highlight language-text">Committable</code>. All of them implement <code class="code highlight language-text">DomUIControl</code>. Note that they are not Swing components — they are only a way of connecting DOM model and Swing components. One end of the connection — the DOM element — is usually specified in the controls constructor. The other end — Swing component — can be obtained in 2 ways. The first is to ask DOM control to create it. But that is rather inconvenient if you want to create the forms in, say, IntelliJ IDEA’s GUI Designer. In that case, you’ll need the second way: ask the control to <code class="code highlight language-text">bind()</code> to an existing Swing component of a correct type (that depends on the type of value that you’re editing). After that, your Swing components will be synchronized with DOM, they’ll even highlight errors reported by <code class="code highlight language-text">DomElementsAnnotator</code>.</p>

<p>Sometimes you may need to do some work (enable or disable some components, change their values) after a particular DOM control is committed. Then you should define the <code class="code highlight language-text">addCommitListener()</code> method of that DOM control and override the <code class="code highlight language-text">CommitListener.afterCommit()</code> method. This method will be invoked inside the same write action as the main <code class="code highlight language-text">commit()</code>, so any changes you do in this method to the XML will be merged with the <code class="code highlight language-text">commit()</code> in the Undo queue.</p>

<a name="simple-controls" class="elem-anchor"></a>
<h3>Simple Controls<a href="#simple-controls" class="anchor-link"><span></span></a></h3>
<p>With simple controls, you can edit <code class="code highlight language-text">GenericDomValue</code>: simple text, class names, enums and boolean values. These controls take a special object as a constructor parameter. This object should implement the <code class="code highlight language-text">DomWrapper</code> interface that knows how to set/get values to/from DOM model.</p>

<p>We have three major DomWrapper’s: <a href="https://upsource.jetbrains.com/idea-ce/file/idea-ce-e2d423f42b53eafd5c625b93149a0ebc7e49756c/xml/dom-openapi/src/com/intellij/util/xml/ui/DomFixedWrapper.java" data-bypass="yes" target="_blank"><span><code class="code highlight language-text">DomFixedWrapper&lt;T&gt;</code></span></a> redirecting calls to <a href="https://upsource.jetbrains.com/idea-ce/file/idea-ce-e2d423f42b53eafd5c625b93149a0ebc7e49756c/xml/dom-openapi/src/com/intellij/util/xml/GenericDomValue.java" data-bypass="yes" target="_blank"><span><code class="code highlight language-text">GenericDomValue&lt;T&gt;</code></span></a>, <a href="https://upsource.jetbrains.com/idea-ce/file/idea-ce-e2d423f42b53eafd5c625b93149a0ebc7e49756c/xml/dom-openapi/src/com/intellij/util/xml/ui/DomStringWrapper.java" data-bypass="yes" target="_blank"><span><code class="code highlight language-text">DomStringWrapper</code></span></a> redirecting calls to string accessors of <a href="https://upsource.jetbrains.com/idea-ce/file/idea-ce-e2d423f42b53eafd5c625b93149a0ebc7e49756c/xml/dom-openapi/src/com/intellij/util/xml/GenericDomValue.java" data-bypass="yes" target="_blank"><span><code class="code highlight language-text">GenericDomValue</code></span></a>, and <a href="https://upsource.jetbrains.com/idea-ce/file/idea-ce-e2d423f42b53eafd5c625b93149a0ebc7e49756c/xml/dom-openapi/src/com/intellij/util/xml/ui/DomCollectionWrapper.java" data-bypass="yes" target="_blank"><span><code class="code highlight language-text">DomCollectionWrapper</code></span></a> that gets/sets values of the first element of the given <a href="https://upsource.jetbrains.com/idea-ce/file/idea-ce-e2d423f42b53eafd5c625b93149a0ebc7e49756c/xml/dom-openapi/src/com/intellij/util/xml/GenericDomValue.java" data-bypass="yes" target="_blank"><span><code class="code highlight language-text">GenericDomValue</code></span></a> collection. Some controls (those having a text field as part of itself) take additional boolean constructor parameter — <em>commitOnEveryChange</em>, whose meaning is evident from the name. We don’t recommend using it anywhere except small dialogs, because committing on every change slows down the system significantly.</p>

<p>Most often these controls are created by <code class="code highlight language-text">DomUIFactory.createControl(GenericDomValue)</code>. This method understands which control to create by using DOM reflection (<code class="code highlight language-text">DomGenericInfo</code>, as you probably remember). But sometimes you may want to create the controls directly. So let’s look at the simple controls more closely.</p>

<a name="booleancontrol" class="elem-anchor"></a>
<h5>BooleanControl</h5>
<p>It allows you to edit boolean values. The control is bound to <code class="code highlight language-text">JCheckBox</code>.</p>

<p><img src="img/xml_dom_api/booleancontrol.gif" alt="BooleanControl" /></p>

<a name="combocontrol" class="elem-anchor"></a>
<h5>ComboControl</h5>
<p>The control is bound to a non-editable <code class="code highlight language-text">JComboBox</code>, so it can be used to choose something from a limited set. One case of such a limited set is enum. Or it can be a constructor where you can provide a <code class="code highlight language-text">Factory&lt;List&lt;String&gt;&gt;</code>, and return from this factory anything you want (for example, a list of database names to choose from). By default, the wrong values (written in XML, but not present in the list you’ve given to the control) are displayed in red. Since it’s common practice to specify custom <code class="code highlight language-text">CellRenderer</code> for combo boxes, the control has the <code class="code highlight language-text">isValidValue(String)</code> method. If it returns <code class="code highlight language-text">false</code> on the value you’re rendering, you can highlight it in some way, to achieve the same result as the default renderer. Or you can just delegate to that renderer in your own way.</p>

<p><img src="img/xml_dom_api/combocontrol.gif" alt="ComboControl" /></p>

<a name="booleanenumcontrol" class="elem-anchor"></a>
<h5>BooleanEnumControl</h5>
<p>Sometimes, when there are only 2 alternatives, it’s convenient to use a check box instead of combo box. This control is designed specially for such cases. While being (and being bound to) a check box, the control edits not just “true” or “false”, but any two String values, or two enum elements. In the last case, it has a boolean <em>invertedOrder</em> parameter, to specify which element corresponds to the checked state. By default <em>invertedOrder</em> is set to <code class="code highlight language-text">false</code>, so the first element corresponds to the unchecked state, and the second — to the checked one. If you set the parameter to <code class="code highlight language-text">true</code>, the states will swap.</p>

<a name="editor-based-controls" class="elem-anchor"></a>
<h3>Editor-based Controls<a href="#editor-based-controls" class="anchor-link"><span></span></a></h3>
<p>Please note that editor-based controls are built on IntelliJ Platform’s <code class="code highlight language-text">Editor</code> instead of standard <code class="code highlight language-text">JTextField</code>. Since there’s currently no way to instantiate Editor directly through the Open API, controls are bound to special <code class="code highlight language-text">JPanel</code> inheritors, and their <code class="code highlight language-text">bind()</code> method adds the necessary content to those panels.</p>

<a name="textcontrol" class="elem-anchor"></a>
<h5>TextControl</h5>
<p>This control allows you to edit simple string values. The control is bound to a <code class="code highlight language-text">TextPanel</code> component. There’s also an inheritor of that panel — <code class="code highlight language-text">MultiLineTextPanel</code>. If you bind a <code class="code highlight language-text">StringControl</code> to it, a big editor will appear on the screen. In case you don’t have space for a big editor, bind it to a <code class="code highlight language-text">BigTextPanel</code>. Then it will be filled with a text editor, and the browse button will be added to open a dialog with the big editor where you can type a longer string.</p>

<a name="psiclasscontrol" class="elem-anchor"></a>
<h5>PsiClassControl</h5>
<p>This is a one-line editor with a browse button that opens the standard  class selection dialog. The control accepts class names only. It is bound to <code class="code highlight language-text">PsiClassPanel</code>.</p>

<p><img src="img/xml_dom_api/psiclasscontrol.gif" alt="PsiClassControl" /></p>

<a name="psitypecontrol" class="elem-anchor"></a>
<h5>PsiTypeControl</h5>
<p>This is almost the same as PsiClassControl, but allows entering not only class names, but also Java primitive types and even arrays. It is bound to <code class="code highlight language-text">PsiTypePanel</code>.</p>

<a name="collection-control" class="elem-anchor"></a>
<h3>Collection Control<a href="#collection-control" class="anchor-link"><span></span></a></h3>
<p>There is a special table component where each row represents one collection child. It’s called <code class="code highlight language-text">DomCollectionControl&lt;T&gt;</code>, where <code class="code highlight language-text">T</code> is your collection element type. To function properly, it needs <code class="code highlight language-text">DomElement</code> (parent of the collection), some description of the collection (sub-tag name or a <code class="code highlight language-text">DomCollectionChildDescription</code> from DOM reflection), and a <code class="code highlight language-text">ColumnInfo</code> array. This can be passed to the constructor, or can be created in a <code class="code highlight language-text">DomCollectionControl</code> inheritor, in an overriden method <code class="code highlight language-text">createColumnInfos()</code>.</p>

<p>What is a column info? It’s just a somewhat more comfortable way to work with the table model. It uses Java 5 generics and is more object-oriented. So, it’s named <code class="code highlight language-text">ColumnInfo&lt;Item,Aspect&gt;</code>, where <code class="code highlight language-text">Item</code> is a type variable corresponding to the type of elements in the collection, and <code class="code highlight language-text">Aspect</code> is a type variable corresponding to this particular column information type: <code class="code highlight language-text">String</code>, <code class="code highlight language-text">PsiClass</code>, <code class="code highlight language-text">Boolean</code>, etc. The basic things that a column knows are: column name, column class, reading value (Aspect <code class="code highlight language-text">valueOf(Item)</code>), writing value (<code class="code highlight language-text">setValue(Item item, Aspect aspect)</code>), cell renderer (<code class="code highlight language-text">getRenderer(Item)</code>), cell “editability” (<code class="code highlight language-text">isCellEditable(Item)</code>), cell editor (<code class="code highlight language-text">getEditor(Item)</code>), etc.</p>

<p>There are a lot of predefined column infos, so you’ll probably never create a new one.</p>

<p>First, if a collection child is a <code class="code highlight language-text">GenericDomValue</code>, it’s usually convenient to edit it directly in the table. For this, you may need one of the following classes: <code class="code highlight language-text">StringColumnInfo</code>, <code class="code highlight language-text">BooleanColumnInfo</code>, or more generic <code class="code highlight language-text">GenericValueColumnInfo</code>. But such collections are encountered very rarely.</p>

<p>A more common case is when a collection element is more complex and has several <code class="code highlight language-text">GenericDomValue</code> children. Then one may create a column for each of those children. The appropriate column info is <code class="code highlight language-text">ChildGenericValueColumnInfo&lt;T&gt;</code>. It will ask you for a <code class="code highlight language-text">DomFixedChildDescription</code> (one more thing from DOM reflection), a renderer and an editor — nothing else. So, the main things left to customize are the renderer and the editor.</p>

<p>As for the renderer, there are two main choices: <code class="code highlight language-text">DefaultTableCellRenderer</code>, and IntelliJ Platform’s <code class="code highlight language-text">BooleanTableCellRenderer</code>. Editors are more complicated, but they closely resemble simple DOM controls.</p>

<p><code class="code highlight language-text">BooleanTableCellEditor</code>, <code class="code highlight language-text">DefaultCellEditor(JTextField)</code>, <code class="code highlight language-text">ComboTableCellEditor</code>, etc. <code class="code highlight language-text">DomUIFactory.createCellEditor()</code> will create any of them automatically (including the editor for <code class="code highlight language-text">PsiClass</code>), so that you won’t need to think about which one to select every time.</p>

<p>Collection control is a complex control, so it’s bound to a complex Swing component. It’s called <a href="https://upsource.jetbrains.com/idea-ce/file/idea-ce-e2d423f42b53eafd5c625b93149a0ebc7e49756c/xml/dom-openapi/src/com/intellij/util/xml/ui/DomTableView.java" data-bypass="yes" target="_blank"><span><code class="code highlight language-text">DomTableView</code></span></a>. It has a toolbar (you can override <code class="code highlight language-text">DomTableView.getToolbarPosition()</code> to customize its location), with Add and Delete buttons. If you want, you may specify custom addition actions in <code class="code highlight language-text">DomCollectionControl.createAdditionActions()</code> (it’s recommended to extend <code class="code highlight language-text">ControlAddAction</code>). If there is only one addition action, it will be invoked after pressing the Add button; if there are many, then a popup menu will be displayed. To change the removal policy, override the <code class="code highlight language-text">DomCollectionControl.doRemove(List&lt;T&gt;)</code> method.</p>

<p>The toolbar may also have an Edit button, if you specify that <code class="code highlight language-text">DomCollectionControl.isEditable()</code>. To add a behavior to this button, override <code class="code highlight language-text">DomCollectionControl.doEdit(T)</code>. There can also be a Help button, if you pass a non-null String <em>helpId</em> parameter while constructing your <code class="code highlight language-text">DomTableView</code>.</p>

<p>If there are no items in the collection, <code class="code highlight language-text">DomTableView</code> may display a special text (<code class="code highlight language-text">DomTableView.getEmptyPaneText()</code>), instead of an empty table.</p>

<p>You can add your own popup menu to the control. Call the <code class="code highlight language-text">DomTableView.installPopup()</code> method after construction, and pass a <code class="code highlight language-text">DefaultActionGroup</code> with your popup actions.</p>

<p>Tables can have single or multiple (default) row selection. If you want to change this behavior, override <code class="code highlight language-text">DomTableView.allowMultipleRowsSelection()</code>.</p>

<p><img src="img/xml_dom_api/collectioncontrol.gif" alt="CollectionControl" /></p>

<a name="ui-organization" class="elem-anchor"></a>
<h3>UI Organization<a href="#ui-organization" class="anchor-link"><span></span></a></h3>
<p>The easiest way to create a DOM-based UI form is to extend the <a href="https://upsource.jetbrains.com/idea-ce/file/idea-ce-e2d423f42b53eafd5c625b93149a0ebc7e49756c/xml/dom-openapi/src/com/intellij/util/xml/ui/BasicDomElementComponent.java" data-bypass="yes" target="_blank"><span><code class="code highlight language-text">BasicDomElementComponent</code></span></a> class. This will require you to pass some DOM element to the constructor. Then you bind an IntelliJ IDEA GUI Designer form to your subclass and design a beautiful form there. You will surely want to bind some controls to DOM UI, in which case you should of course ensure that they have right types. Finally, you should create some DOM controls in class’ constructor and bind them. But you can create controls and bind them to the <code class="code highlight language-text">DomElement</code>’s children — <code class="code highlight language-text">GenericDomValue</code>’s automatically.</p>

<p>Just name your components properly and call the <code class="code highlight language-text">bindProperties()</code> method in the constructor. The field names should correspond to the getter names for the element’s children. They may also be prefixed with “my”. Imagine that you have such DOM interface:</p>

<div class="code-block" data-lang="java"><code class="code-block__wrapper"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Converter</span> <span class="kd">extends</span> <span class="n">DomElement</span> <span class="o">{</span>
    <span class="n">GenericDomValue</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="nf">getConverterId</span><span class="o">();</span>
    <span class="n">GenericDomValue</span><span class="o">&lt;</span><span class="n">PsiClass</span><span class="o">&gt;</span> <span class="nf">getConverterClass</span><span class="o">();</span>
<span class="o">}</span>
</code></div>

<p>In this case, the UI form class can look like this:</p>

<div class="code-block" data-lang="java"><code class="code-block__wrapper"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ConverterComponent</span> <span class="kd">extends</span> <span class="n">BasicDomElementComponent</span><span class="o">&lt;</span><span class="n">Converter</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">JPanel</span> <span class="n">myRootPane</span><span class="o">;</span>
    <span class="kd">private</span> <span class="n">TextPanel</span> <span class="n">myConverterId</span><span class="o">;</span>
    <span class="kd">private</span> <span class="n">PsiClassPanel</span> <span class="n">myConverterClass</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">ConverterComponent</span><span class="o">(</span><span class="kd">final</span> <span class="n">Converter</span> <span class="n">domElement</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">domElement</span><span class="o">);</span>

        <span class="n">bindProperties</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></div>
<p>All the fields here are now bound to controls in a GUI form.</p>

<p>Very often you’ll have to create your own file editor. Then, to use all the binding and undo functionality, it’s suggested to inherit your <a href="https://upsource.jetbrains.com/idea-ce/file/idea-ce-e2d423f42b53eafd5c625b93149a0ebc7e49756c/platform/platform-api/src/com/intellij/openapi/fileEditor/FileEditorProvider.java" data-bypass="yes" target="_blank"><span><code class="code highlight language-text">FileEditorProvider</code></span></a> from <a href="https://upsource.jetbrains.com/idea-ce/file/idea-ce-e2d423f42b53eafd5c625b93149a0ebc7e49756c/xml/dom-openapi/src/com/intellij/util/xml/ui/PerspectiveFileEditorProvider.java" data-bypass="yes" target="_blank"><span><code class="code highlight language-text">PerspectiveFileEditorProvider</code></span></a>, create an instance of <a href="https://upsource.jetbrains.com/idea-ce/file/idea-ce-e2d423f42b53eafd5c625b93149a0ebc7e49756c/xml/dom-openapi/src/com/intellij/util/xml/ui/DomFileEditor.java" data-bypass="yes" target="_blank"><span><code class="code highlight language-text">DomFileEditor</code></span></a> there, and pass a <a href="https://upsource.jetbrains.com/idea-ce/file/idea-ce-e2d423f42b53eafd5c625b93149a0ebc7e49756c/xml/dom-openapi/src/com/intellij/util/xml/ui/BasicDomElementComponent.java" data-bypass="yes" target="_blank"><span><code class="code highlight language-text">BasicDomElementComponent</code></span></a>. To easily create an editor with a caption at the top, like in our EJB and JSF, you may use the static method <code class="code highlight language-text">DomFileEditor.createDomFileEditor()</code>. <code class="code highlight language-text">DomFileEditor</code> automatically listens to all changes in the document corresponding to the given DOM element, and therefore refreshes your component on undo. If you want to listen to changes in additional documents, use the methods <code class="code highlight language-text">addWatchedDocument()</code>, <code class="code highlight language-text">removeWatchedDocument()</code>, <code class="code highlight language-text">addWatchedElement()</code>, <code class="code highlight language-text">removeWatchedElement()</code> in <code class="code highlight language-text">DomFileEditor</code>.</p>

<a name="conclusion" class="elem-anchor"></a>
<h2>Conclusion<a href="#conclusion" class="anchor-link"><span></span></a></h2>
<p>Thank you for your time and attention. We hope you’ve found this article really useful. You are welcome to post your questions and comments to our <a href="https://intellij-support.jetbrains.com/hc/en-us/community/topics/200366979-IntelliJ-IDEA-Open-API-and-Plugin-Development" data-bypass="yes" target="_blank"><span>Open API and Plugin Development Forum</span></a>.</p>

<a name="further-material" class="elem-anchor"></a>
<h3>Further Material<a href="#further-material" class="anchor-link"><span></span></a></h3>
<p>The following bundled open source plugins make (heavy) use of DOM:</p>

<ul>
  <li><a href="https://github.com/JetBrains/android" data-bypass="yes" target="_blank"><span>Android</span></a></li>
  <li><a href="https://upsource.jetbrains.com/idea-ce/file/idea-ce-e2d423f42b53eafd5c625b93149a0ebc7e49756c/plugins/ant" data-bypass="yes" target="_blank"><span>Ant</span></a></li>
  <li><a href="https://upsource.jetbrains.com/idea-ce/file/idea-ce-e2d423f42b53eafd5c625b93149a0ebc7e49756c/plugins/devkit/devkit-core" data-bypass="yes" target="_blank"><span>Plugin DevKit</span></a></li>
  <li><a href="https://upsource.jetbrains.com/idea-ce/file/idea-ce-e2d423f42b53eafd5c625b93149a0ebc7e49756c/plugins/maven" data-bypass="yes" target="_blank"><span>Maven</span></a></li>
  <li><a href="https://github.com/JetBrains/intellij-plugins/tree/master/struts2" data-bypass="yes" target="_blank"><span>Struts 2</span></a> (Ultimate Edition)</li>
</ul>



                    <div class="navigation-links _bottom" data-swiftype-index="false">
                        <a class="navigation-links__prev" href="/basics/indexing_and_psi_stubs.html">Indexing and PSI Stubs</a>
                        <a class="navigation-links__next" href="/basics/editing.html">Editing</a>
                    </div>
                    <div class="last-modified">
                        Last modified: 19 February 2020
                    </div>
                </article>

                <section class="disqus">
                    <div id="disqus_thread"></div>
                </section>
            </div>
        </section>
    </main>
</div>

<script src="/intellij/sdk/docs/app/app.js" data-baseurl="/intellij/sdk/docs/"></script>

</body>
</html>

